<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>opening_hours.models.times API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>opening_hours.models.times</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from opening_hours.models.time import Time, TimeType
from opening_hours.patterns import timerange
import logging, os
from opening_hours.helpers import normalize_string

logger = logging.getLogger(__name__)

class Times():
        &#34;&#34;&#34;
        Similar to Days, this class represents a range of times and provides methods
        to help reate them from common shortcuts. No iterator here though since
        there isnt really a need to iterate over every single time within a range.
        &#34;&#34;&#34;
        start_time = None
        end_time = None
        
        @classmethod
        def parse(cls, times_string, assume_type=None):
                &#34;&#34;&#34;
                parse a time object from a string using the pyparsing patterns for a time range
                This function will normalize the input value first and will raise a TypeError if None is given.
                &#34;&#34;&#34;
                logger.debug(&#34;creating times object from string: &#34; + times_string)
                if times_string is None:
                        raise TypeError(&#34;Cannot create Times Object from value None&#34;)
                        
                times_string = normalize_string(times_string)

                return cls.from_parse_results(timerange.parseString(times_string), assume_type=assume_type)

        @classmethod
        def from_parse_results(cls, result, assume_type=None):
                &#34;&#34;&#34;
                Takes values from pyparsing results and converts them to an instance of this object. This makes heavy use of the output names defined for certain patterns to help pick out only the relevant data.
                This is primarily for internal use and is helpful when combined with the parse() functions of this or other objects.
                &#34;&#34;&#34;
                # assumes that all three (hours, minutes, am_pm) are the same length
                res_dct = result.asDict()
                logger.debug(res_dct)
                if &#34;starttime&#34; in res_dct and &#34;endtime&#34; in res_dct: 
                        logger.info(&#34;time range detected&#34;)
                        start = res_dct.get(&#34;starttime&#34;)[0]
                        starttime = Time.from_parse_results(start)
                        
                        end = res_dct.get(&#34;endtime&#34;)[0]
                        endtime = Time.from_parse_results(end)
                        
                        if starttime.is_unknown() and assume_type is not None:
                                starttime.set_type(assume_type)

                        if endtime.is_unknown() and assume_type is not None:
                                endtime.set_type(assume_type)


                        if starttime.is_am() and endtime.is_am() and starttime.get_hours() &gt; endtime.get_hours():
                                endtime.set_type(TimeType.PM)

                        return cls(starttime, endtime)
                elif &#34;time_shortcuts&#34; in res_dct: 
                        logger.info(&#34;time shortcut detected&#34;)
                        return cls.from_shortcut_string(result.get(&#34;time_shortcuts&#34;)[0])
                else:
                        logger.info(&#34;unspecified time pattern detected&#34;)
                        logger.debug(vars(result))
                        # nothing specified, assumeit means every day
                        return cls(Time(0, 0, TimeType.AM), Time(11, 59, TimeType.PM))

        @classmethod
        def from_shortcut_string(cls, times_shortcut, assume_type=None):
                &#34;&#34;&#34;
                create a times object from a shortcut string, such as are used to represent time ranges such as &#34;24 hours&#34;, or &#34;work hours&#34;.

                This is primarily for internal use and is helpful when combined with the parse() functions of this or other objects.

                &#34;&#34;&#34;
                logger.debug(&#34;creating times object from shortcut: &#34; + (times_shortcut or &#34;None&#34;))
                if times_shortcut is None:
                        raise TypeError(&#34;Cannot create Times Object from value None&#34;)
                        
                times = times_shortcut.lower()

                # set up some shortcut ranges
                allday = cls(Time(0, 0, TimeType.AM), Time(11, 59, TimeType.PM))
                workhours = cls(Time(9, 0, TimeType.AM), Time(5, 0, TimeType.PM))
                closed = cls(None, None)

                if &#34;24&#34; in times:
                        return allday
                elif &#34;business&#34; in times:
                        return workhours
                elif &#34;work&#34; in times:
                        return workhours
                elif &#34;all day&#34; in times:
                        return allday
                elif &#34;closed&#34; in times:
                        return closed
                elif &#34;null&#34; in times:
                        return closed


                raise ValueError(&#34;string &#39;&#34; + times_shortcut or &#34;[NoneType]&#34; + &#34;&#39; does not match a known pattern&#34;)

                
        def __init__(self, start_time, end_time):
                &#34;&#34;&#34;
                Creates a Times object from two Time objects
                &#34;&#34;&#34;
                # if start_time is None or end_time is None:
                #       raise TypeError(&#34;Cannot create Times Object from value None&#34;)
        
                logger.debug(&#34;creating times from &#34; + str(start_time or &#34;None&#34;) + &#34; and &#34; + str(end_time or &#34;None&#34;))

                self.start_time = start_time
                self.end_time = end_time

        def get_start_time(self):
                return self.start_time
        
        def get_end_time(self):
                return self.end_time
        
        def is_closed(self):
                has_none = self.start_time is None or self.end_time is None
                times_match = self.start_time == self.end_time
                return has_none or times_match

        #TODO: possibly add a function to see if a single Time is within the range 
        # specified by this Times object 


        #TODO: getduration function
        
        def __str__(self):
                if self.is_closed():
                        return &#34;closed&#34;
                else:
                        return str(self.start_time.get_as_military_time()) + &#34; to &#34; + str(self.end_time.get_as_military_time())

        
        def json(self):
                if self.is_closed():
                        return {}
                else:
                        return {
                                &#34;opens&#34;: str(self.start_time.get_as_military_time()),
                                &#34;closes&#34;: str(self.end_time.get_as_military_time())
                                }

        
        def __eq__(self, other):
                if not isinstance(other, Times):
                        # don&#39;t attempt to compare against unrelated types
                        raise NotImplementedError()
                return self.start_time == other.start_time and self.end_time == other.end_time </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="opening_hours.models.times.Times"><code class="flex name class">
<span>class <span class="ident">Times</span></span>
<span>(</span><span>start_time, end_time)</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to Days, this class represents a range of times and provides methods
to help reate them from common shortcuts. No iterator here though since
there isnt really a need to iterate over every single time within a range.</p>
<p>Creates a Times object from two Time objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Times():
        &#34;&#34;&#34;
        Similar to Days, this class represents a range of times and provides methods
        to help reate them from common shortcuts. No iterator here though since
        there isnt really a need to iterate over every single time within a range.
        &#34;&#34;&#34;
        start_time = None
        end_time = None
        
        @classmethod
        def parse(cls, times_string, assume_type=None):
                &#34;&#34;&#34;
                parse a time object from a string using the pyparsing patterns for a time range
                This function will normalize the input value first and will raise a TypeError if None is given.
                &#34;&#34;&#34;
                logger.debug(&#34;creating times object from string: &#34; + times_string)
                if times_string is None:
                        raise TypeError(&#34;Cannot create Times Object from value None&#34;)
                        
                times_string = normalize_string(times_string)

                return cls.from_parse_results(timerange.parseString(times_string), assume_type=assume_type)

        @classmethod
        def from_parse_results(cls, result, assume_type=None):
                &#34;&#34;&#34;
                Takes values from pyparsing results and converts them to an instance of this object. This makes heavy use of the output names defined for certain patterns to help pick out only the relevant data.
                This is primarily for internal use and is helpful when combined with the parse() functions of this or other objects.
                &#34;&#34;&#34;
                # assumes that all three (hours, minutes, am_pm) are the same length
                res_dct = result.asDict()
                logger.debug(res_dct)
                if &#34;starttime&#34; in res_dct and &#34;endtime&#34; in res_dct: 
                        logger.info(&#34;time range detected&#34;)
                        start = res_dct.get(&#34;starttime&#34;)[0]
                        starttime = Time.from_parse_results(start)
                        
                        end = res_dct.get(&#34;endtime&#34;)[0]
                        endtime = Time.from_parse_results(end)
                        
                        if starttime.is_unknown() and assume_type is not None:
                                starttime.set_type(assume_type)

                        if endtime.is_unknown() and assume_type is not None:
                                endtime.set_type(assume_type)


                        if starttime.is_am() and endtime.is_am() and starttime.get_hours() &gt; endtime.get_hours():
                                endtime.set_type(TimeType.PM)

                        return cls(starttime, endtime)
                elif &#34;time_shortcuts&#34; in res_dct: 
                        logger.info(&#34;time shortcut detected&#34;)
                        return cls.from_shortcut_string(result.get(&#34;time_shortcuts&#34;)[0])
                else:
                        logger.info(&#34;unspecified time pattern detected&#34;)
                        logger.debug(vars(result))
                        # nothing specified, assumeit means every day
                        return cls(Time(0, 0, TimeType.AM), Time(11, 59, TimeType.PM))

        @classmethod
        def from_shortcut_string(cls, times_shortcut, assume_type=None):
                &#34;&#34;&#34;
                create a times object from a shortcut string, such as are used to represent time ranges such as &#34;24 hours&#34;, or &#34;work hours&#34;.

                This is primarily for internal use and is helpful when combined with the parse() functions of this or other objects.

                &#34;&#34;&#34;
                logger.debug(&#34;creating times object from shortcut: &#34; + (times_shortcut or &#34;None&#34;))
                if times_shortcut is None:
                        raise TypeError(&#34;Cannot create Times Object from value None&#34;)
                        
                times = times_shortcut.lower()

                # set up some shortcut ranges
                allday = cls(Time(0, 0, TimeType.AM), Time(11, 59, TimeType.PM))
                workhours = cls(Time(9, 0, TimeType.AM), Time(5, 0, TimeType.PM))
                closed = cls(None, None)

                if &#34;24&#34; in times:
                        return allday
                elif &#34;business&#34; in times:
                        return workhours
                elif &#34;work&#34; in times:
                        return workhours
                elif &#34;all day&#34; in times:
                        return allday
                elif &#34;closed&#34; in times:
                        return closed
                elif &#34;null&#34; in times:
                        return closed


                raise ValueError(&#34;string &#39;&#34; + times_shortcut or &#34;[NoneType]&#34; + &#34;&#39; does not match a known pattern&#34;)

                
        def __init__(self, start_time, end_time):
                &#34;&#34;&#34;
                Creates a Times object from two Time objects
                &#34;&#34;&#34;
                # if start_time is None or end_time is None:
                #       raise TypeError(&#34;Cannot create Times Object from value None&#34;)
        
                logger.debug(&#34;creating times from &#34; + str(start_time or &#34;None&#34;) + &#34; and &#34; + str(end_time or &#34;None&#34;))

                self.start_time = start_time
                self.end_time = end_time

        def get_start_time(self):
                return self.start_time
        
        def get_end_time(self):
                return self.end_time
        
        def is_closed(self):
                has_none = self.start_time is None or self.end_time is None
                times_match = self.start_time == self.end_time
                return has_none or times_match

        #TODO: possibly add a function to see if a single Time is within the range 
        # specified by this Times object 


        #TODO: getduration function
        
        def __str__(self):
                if self.is_closed():
                        return &#34;closed&#34;
                else:
                        return str(self.start_time.get_as_military_time()) + &#34; to &#34; + str(self.end_time.get_as_military_time())

        
        def json(self):
                if self.is_closed():
                        return {}
                else:
                        return {
                                &#34;opens&#34;: str(self.start_time.get_as_military_time()),
                                &#34;closes&#34;: str(self.end_time.get_as_military_time())
                                }

        
        def __eq__(self, other):
                if not isinstance(other, Times):
                        # don&#39;t attempt to compare against unrelated types
                        raise NotImplementedError()
                return self.start_time == other.start_time and self.end_time == other.end_time </code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="opening_hours.models.times.Times.end_time"><code class="name">var <span class="ident">end_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opening_hours.models.times.Times.start_time"><code class="name">var <span class="ident">start_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="opening_hours.models.times.Times.from_parse_results"><code class="name flex">
<span>def <span class="ident">from_parse_results</span></span>(<span>result, assume_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes values from pyparsing results and converts them to an instance of this object. This makes heavy use of the output names defined for certain patterns to help pick out only the relevant data.
This is primarily for internal use and is helpful when combined with the parse() functions of this or other objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_parse_results(cls, result, assume_type=None):
        &#34;&#34;&#34;
        Takes values from pyparsing results and converts them to an instance of this object. This makes heavy use of the output names defined for certain patterns to help pick out only the relevant data.
        This is primarily for internal use and is helpful when combined with the parse() functions of this or other objects.
        &#34;&#34;&#34;
        # assumes that all three (hours, minutes, am_pm) are the same length
        res_dct = result.asDict()
        logger.debug(res_dct)
        if &#34;starttime&#34; in res_dct and &#34;endtime&#34; in res_dct: 
                logger.info(&#34;time range detected&#34;)
                start = res_dct.get(&#34;starttime&#34;)[0]
                starttime = Time.from_parse_results(start)
                
                end = res_dct.get(&#34;endtime&#34;)[0]
                endtime = Time.from_parse_results(end)
                
                if starttime.is_unknown() and assume_type is not None:
                        starttime.set_type(assume_type)

                if endtime.is_unknown() and assume_type is not None:
                        endtime.set_type(assume_type)


                if starttime.is_am() and endtime.is_am() and starttime.get_hours() &gt; endtime.get_hours():
                        endtime.set_type(TimeType.PM)

                return cls(starttime, endtime)
        elif &#34;time_shortcuts&#34; in res_dct: 
                logger.info(&#34;time shortcut detected&#34;)
                return cls.from_shortcut_string(result.get(&#34;time_shortcuts&#34;)[0])
        else:
                logger.info(&#34;unspecified time pattern detected&#34;)
                logger.debug(vars(result))
                # nothing specified, assumeit means every day
                return cls(Time(0, 0, TimeType.AM), Time(11, 59, TimeType.PM))</code></pre>
</details>
</dd>
<dt id="opening_hours.models.times.Times.from_shortcut_string"><code class="name flex">
<span>def <span class="ident">from_shortcut_string</span></span>(<span>times_shortcut, assume_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>create a times object from a shortcut string, such as are used to represent time ranges such as "24 hours", or "work hours".</p>
<p>This is primarily for internal use and is helpful when combined with the parse() functions of this or other objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_shortcut_string(cls, times_shortcut, assume_type=None):
        &#34;&#34;&#34;
        create a times object from a shortcut string, such as are used to represent time ranges such as &#34;24 hours&#34;, or &#34;work hours&#34;.

        This is primarily for internal use and is helpful when combined with the parse() functions of this or other objects.

        &#34;&#34;&#34;
        logger.debug(&#34;creating times object from shortcut: &#34; + (times_shortcut or &#34;None&#34;))
        if times_shortcut is None:
                raise TypeError(&#34;Cannot create Times Object from value None&#34;)
                
        times = times_shortcut.lower()

        # set up some shortcut ranges
        allday = cls(Time(0, 0, TimeType.AM), Time(11, 59, TimeType.PM))
        workhours = cls(Time(9, 0, TimeType.AM), Time(5, 0, TimeType.PM))
        closed = cls(None, None)

        if &#34;24&#34; in times:
                return allday
        elif &#34;business&#34; in times:
                return workhours
        elif &#34;work&#34; in times:
                return workhours
        elif &#34;all day&#34; in times:
                return allday
        elif &#34;closed&#34; in times:
                return closed
        elif &#34;null&#34; in times:
                return closed


        raise ValueError(&#34;string &#39;&#34; + times_shortcut or &#34;[NoneType]&#34; + &#34;&#39; does not match a known pattern&#34;)</code></pre>
</details>
</dd>
<dt id="opening_hours.models.times.Times.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>times_string, assume_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>parse a time object from a string using the pyparsing patterns for a time range
This function will normalize the input value first and will raise a TypeError if None is given.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, times_string, assume_type=None):
        &#34;&#34;&#34;
        parse a time object from a string using the pyparsing patterns for a time range
        This function will normalize the input value first and will raise a TypeError if None is given.
        &#34;&#34;&#34;
        logger.debug(&#34;creating times object from string: &#34; + times_string)
        if times_string is None:
                raise TypeError(&#34;Cannot create Times Object from value None&#34;)
                
        times_string = normalize_string(times_string)

        return cls.from_parse_results(timerange.parseString(times_string), assume_type=assume_type)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opening_hours.models.times.Times.get_end_time"><code class="name flex">
<span>def <span class="ident">get_end_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_time(self):
        return self.end_time</code></pre>
</details>
</dd>
<dt id="opening_hours.models.times.Times.get_start_time"><code class="name flex">
<span>def <span class="ident">get_start_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_start_time(self):
        return self.start_time</code></pre>
</details>
</dd>
<dt id="opening_hours.models.times.Times.is_closed"><code class="name flex">
<span>def <span class="ident">is_closed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_closed(self):
        has_none = self.start_time is None or self.end_time is None
        times_match = self.start_time == self.end_time
        return has_none or times_match</code></pre>
</details>
</dd>
<dt id="opening_hours.models.times.Times.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self):
        if self.is_closed():
                return {}
        else:
                return {
                        &#34;opens&#34;: str(self.start_time.get_as_military_time()),
                        &#34;closes&#34;: str(self.end_time.get_as_military_time())
                        }</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opening_hours.models" href="index.html">opening_hours.models</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="opening_hours.models.times.Times" href="#opening_hours.models.times.Times">Times</a></code></h4>
<ul class="">
<li><code><a title="opening_hours.models.times.Times.end_time" href="#opening_hours.models.times.Times.end_time">end_time</a></code></li>
<li><code><a title="opening_hours.models.times.Times.from_parse_results" href="#opening_hours.models.times.Times.from_parse_results">from_parse_results</a></code></li>
<li><code><a title="opening_hours.models.times.Times.from_shortcut_string" href="#opening_hours.models.times.Times.from_shortcut_string">from_shortcut_string</a></code></li>
<li><code><a title="opening_hours.models.times.Times.get_end_time" href="#opening_hours.models.times.Times.get_end_time">get_end_time</a></code></li>
<li><code><a title="opening_hours.models.times.Times.get_start_time" href="#opening_hours.models.times.Times.get_start_time">get_start_time</a></code></li>
<li><code><a title="opening_hours.models.times.Times.is_closed" href="#opening_hours.models.times.Times.is_closed">is_closed</a></code></li>
<li><code><a title="opening_hours.models.times.Times.json" href="#opening_hours.models.times.Times.json">json</a></code></li>
<li><code><a title="opening_hours.models.times.Times.parse" href="#opening_hours.models.times.Times.parse">parse</a></code></li>
<li><code><a title="opening_hours.models.times.Times.start_time" href="#opening_hours.models.times.Times.start_time">start_time</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>